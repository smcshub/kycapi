<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video OTP Verification</title>
    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/lucide@latest"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
  </head>
  <body>
    <div class="card">
      <!-- User ID Input Screen -->
      <div id="screen-userid" class="screen-userid active">
        <div class="close-icon"><i data-lucide="x"></i></div>
        <h2>Enter Your User ID</h2>
        <p class="subtitle">
          Please enter your User ID to continue verification
        </p>
        <div class="input-group">
          <input
            type="text"
            id="userid-input"
            placeholder="Enter your User ID"
            maxlength="50"
          />
          <button class="btn btn-primary" onclick="app.verifyUserAndStart()">
            Continue
          </button>
        </div>
        <div id="userid-error" class="error-toast" style="display: none">
          <i data-lucide="alert-circle" width="18"></i>
          <span id="userid-error-message">Invalid User ID</span>
        </div>
        <div class="footer-brand">powered by HyperVerge</div>
      </div>

      <!-- User Profile Screen -->
      <div id="screen-profile" class="screen-profile" style="display: none">
        <div class="verify-header">
          <div class="icon-btn" onclick="app.showUserIdScreen()">
            <i data-lucide="chevron-left"></i>
          </div>
          <div class="icon-btn"><i data-lucide="x"></i></div>
        </div>
        <div class="profile-body">
          <div class="profile-header">
            <h2>User Verification</h2>
            <p class="subtitle">Please verify your identity</p>
          </div>

          <div class="profile-pic-container">
            <div class="profile-pic-wrapper">
              <img id="profile-pic-preview" src="" alt="Profile" />
              <div class="profile-pic-loading" style="display: none">
                <div class="spinner"></div>
                <span>Loading...</span>
              </div>
            </div>
          </div>

          <div class="user-details">
            <div class="detail-item">
              <span class="label">User ID</span>
              <span id="user-id-display" class="value"></span>
            </div>
            <div class="detail-item">
              <span class="label">Full Name</span>
              <span id="user-name-display" class="value"></span>
            </div>
            <div class="detail-item">
              <span class="label">Email</span>
              <span id="user-email-display" class="value"></span>
            </div>
            <div class="detail-item">
              <span class="label">Phone</span>
              <span id="user-phone-display" class="value"></span>
            </div>
            <div class="detail-item">
              <span class="label">KYC Status</span>
              <span id="kyc-status-display" class="value"></span>
            </div>
          </div>
        </div>
        <div class="profile-footer">
          <button class="btn btn-primary" onclick="app.startKycVerification()">
            Start Verification
          </button>
          <div class="footer-brand">
            <div class="dot"></div>
            powered by HyperVerge
          </div>
        </div>
      </div>

      <!-- Verification Screen -->
      <div id="screen-verify" class="screen-verify">
        <div class="verify-header">
          <div class="icon-btn" onclick="app.goBackToLanding()">
            <i data-lucide="chevron-left"></i>
          </div>
          <div class="icon-btn"><i data-lucide="x"></i></div>
        </div>
        <div class="verify-body">
          <div id="error-toast" class="error-toast">
            <i data-lucide="alert-circle" width="18"></i>
            <span id="error-message">No face detected</span>
          </div>
          <div id="instruction-text" class="instruction-text">
            Position your full face inside the circle
          </div>
          <div class="video-wrapper">
            <div id="loading-overlay" class="loading-overlay">
              <i
                data-lucide="refresh-cw"
                class="spin"
                color="#6b7280"
                width="32"
              ></i>
              <p
                style="
                  font-size: 0.8rem;
                  font-weight: 600;
                  margin-top: 10px;
                  color: #111827;
                "
              >
                Loading models...
              </p>
            </div>
            <div id="video-border" class="video-circle no-face">
              <video id="cam-video" autoplay muted playsinline></video>
              <div id="face-status" class="face-status loading">Loading...</div>
              <div id="rec-indicator" class="rec-indicator">
                <div class="rec-dot"></div>
                <span id="timer-text">00:04</span>
              </div>
            </div>
          </div>
          <canvas id="detection-canvas"></canvas>
          <div
            id="face-match-status"
            class="face-match-status"
            style="display: none"
          >
            <i data-lucide="user-check" width="18"></i>
            <span id="face-match-message">Verifying face match...</span>
          </div>
          <div class="prompt-box">
            <div class="prompt-header">
              <i data-lucide="mic" width="16"></i>
              <span>Read the following out loud:</span>
            </div>
            <div id="prompt-text" class="prompt-text"></div>
          </div>
        </div>
        <div class="verify-footer">
          <button
            id="action-btn"
            class="btn btn-primary"
            disabled
            onclick="app.handleAction()"
          >
            Loading...
          </button>
          <div
            class="footer-brand"
            style="
              display: flex;
              justify-content: center;
              align-items: center;
              gap: 4px;
            "
          >
            <div
              style="
                width: 8px;
                height: 8px;
                background: #4ade80;
                border-radius: 50%;
              "
            ></div>
            powered by HyperVerge
          </div>
        </div>
      </div>
    </div>

    <script>
      lucide.createIcons();
      const app = {
        screens: {
          userid: document.getElementById("screen-userid"),
          profile: document.getElementById("screen-profile"),
          verify: document.getElementById("screen-verify"),
        },
        ui: {
          video: document.getElementById("cam-video"),
          videoBorder: document.getElementById("video-border"),
          btn: document.getElementById("action-btn"),
          instruction: document.getElementById("instruction-text"),
          recIndicator: document.getElementById("rec-indicator"),
          timerText: document.getElementById("timer-text"),
          loading: document.getElementById("loading-overlay"),
          errorToast: document.getElementById("error-toast"),
          errorMessage: document.getElementById("error-message"),
          canvas: document.getElementById("detection-canvas"),
          faceStatus: document.getElementById("face-status"),
          useridInput: document.getElementById("userid-input"),
          useridError: document.getElementById("userid-error"),
          useridErrorMessage: document.getElementById("userid-error-message"),
          profilePicPreview: document.getElementById("profile-pic-preview"),
          userIdDisplay: document.getElementById("user-id-display"),
          userNameDisplay: document.getElementById("user-name-display"),
          userEmailDisplay: document.getElementById("user-email-display"),
          userPhoneDisplay: document.getElementById("user-phone-display"),
          kycStatusDisplay: document.getElementById("kyc-status-display"),
          faceMatchStatus: document.getElementById("face-match-status"),
          faceMatchMessage: document.getElementById("face-match-message"),
        },
        stream: null,
        mediaRecorder: null,
        recordedChunks: [],
        videoBlob: null,
        state: "USERID",
        timerInterval: null,
        faceDetectionLoop: null,
        faceDetector: null,
        hands: null,
        modelLoaded: false,
        handsLoaded: false,
        faceApiModelsLoaded: false,
        faceDetected: false,
        consecutiveValid: 0,
        consecutiveInvalid: 0,
        threshold: 4,
        currentHands: [],
        speechRecognition: null,
        recognizedText: "",
        circle: { cx: 0.5, cy: 0.5, r: 0.45 },
        userId: null,
        API_BASE: "http://localhost:5000/api/v1",
        currentUser: null,
        prompts: [],
        currentPromptIndex: 0,
        faceMatched: false,
        faceMatchingInterval: null,
        profileDescriptor: null,
        // Load Face-API models on page load
        init: async function () {
          console.log("Initializing Face-API models...");
          try {
            const MODEL_URL =
              "https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model";
            await Promise.all([
              faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL),
              faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
              faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
            ]);
            this.faceApiModelsLoaded = true;
            console.log("✅ Face-API models loaded successfully");
          } catch (error) {
            console.error("❌ Failed to load Face-API models:", error);
            this.faceApiModelsLoaded = false;
          }
        },
        showUserIdScreen: function () {
          this.screens.userid.style.display = "flex";
          this.screens.profile.style.display = "none";
          this.screens.verify.style.display = "none";
          this.state = "USERID";
        },
        verifyUserAndStart: async function () {
          const userId = this.ui.useridInput.value.trim();
          if (!userId) {
            this.showUserIdError("Please enter your User ID");
            return;
          }
          if (userId.length < 3 || userId.length > 50) {
            this.showUserIdError("User ID must be between 3-50 characters");
            return;
          }
          this.ui.useridError.style.display = "none";
          const continueBtn = this.screens.userid.querySelector("button");
          const originalText = continueBtn.textContent;
          continueBtn.textContent = "Verifying...";
          continueBtn.disabled = true;
          try {
            const response = await fetch(`${this.API_BASE}/users/${userId}`);
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || "User not found");
            }
            const userData = await response.json();
            this.currentUser = userData.data;
            this.userId = userId;
            await this.populateUserProfile();
            if (userData.data.verificationPrompts?.length > 0) {
              this.prompts = userData.data.verificationPrompts;
            } else {
              this.prompts = [
                { type: "otp", text: "5 - 6 - 7 - 8", duration: 4 },
                {
                  type: "sentence",
                  text: "The quick brown fox jumps over the lazy dog",
                  duration: 8,
                },
                {
                  type: "statement",
                  text: "I confirm my identity for account verification",
                  duration: 10,
                },
              ];
            }
            this.screens.userid.style.display = "none";
            this.screens.profile.style.display = "flex";
            this.state = "PROFILE";
          } catch (error) {
            console.error("User verification error:", error);
            this.showUserIdError(error.message || "User verification failed");
          } finally {
            continueBtn.textContent = originalText;
            continueBtn.disabled = false;
          }
        },
        showUserIdError: function (message) {
          this.ui.useridErrorMessage.textContent = message;
          this.ui.useridError.style.display = "flex";
        },
        populateUserProfile: async function () {
          if (!this.currentUser) return;
          this.ui.userIdDisplay.textContent = this.currentUser.userId || "N/A";
          this.ui.userNameDisplay.textContent =
            this.currentUser.fullName || "N/A";
          this.ui.userEmailDisplay.textContent =
            this.currentUser.email || "N/A";
          this.ui.userPhoneDisplay.textContent =
            this.currentUser.phone || "N/A";
          const kycStatus =
            this.currentUser.videoKycStatus ||
            this.currentUser.kycStatus ||
            "pending";
          this.ui.kycStatusDisplay.textContent =
            this.formatKycStatus(kycStatus);
          if (this.currentUser.profilePic) {
            this.showProfilePicLoading();
            try {
              const imageUrl = `${this.API_BASE}/users/files/${this.currentUser.profilePic}`;
              const response = await fetch(imageUrl, {
                method: "GET",
                mode: "cors",
                credentials: "omit",
                headers: { Accept: "image/jpeg,image/png,image/*" },
              });
              if (!response.ok) throw new Error(`HTTP ${response.status}`);
              const blob = await response.blob();
              const objectUrl = URL.createObjectURL(blob);
              this.ui.profilePicPreview.src = objectUrl;
              // Pre-compute face descriptor for profile picture
              if (this.faceApiModelsLoaded) {
                await this.computeProfileDescriptor(objectUrl);
              }
              this.hideProfilePicLoading();
            } catch (error) {
              console.error("Failed to load profile picture:", error);
              this.ui.profilePicPreview.src = "";
              this.hideProfilePicLoading();
            }
          } else {
            this.ui.profilePicPreview.src = "";
            this.hideProfilePicLoading();
          }
        },
        computeProfileDescriptor: async function (imageUrl) {
          try {
            console.log("Computing profile face descriptor...");
            const img = await faceapi.fetchImage(imageUrl);
            const detection = await faceapi
              .detectSingleFace(img)
              .withFaceLandmarks()
              .withFaceDescriptor();
            if (detection) {
              this.profileDescriptor = detection.descriptor;
              console.log("✅ Profile descriptor computed successfully");
            } else {
              console.warn("⚠️ No face detected in profile picture");
              this.profileDescriptor = null;
            }
          } catch (error) {
            console.error("❌ Error computing profile descriptor:", error);
            this.profileDescriptor = null;
          }
        },
        showProfilePicLoading: function () {
          const loadingElement =
            this.ui.profilePicPreview.parentElement.querySelector(
              ".profile-pic-loading"
            );
          if (loadingElement) loadingElement.style.display = "flex";
        },
        hideProfilePicLoading: function () {
          const loadingElement =
            this.ui.profilePicPreview.parentElement.querySelector(
              ".profile-pic-loading"
            );
          if (loadingElement) loadingElement.style.display = "none";
        },
        formatKycStatus: function (status) {
          const statusMap = {
            not_started: "Not Started",
            pending: "Pending",
            verified: "Verified ✅",
            rejected: "Rejected ❌",
            failed: "Failed ❌",
          };
          return statusMap[status] || status;
        },
        startKycVerification: function () {
          if (!this.currentUser.profilePic) {
            if (
              confirm(
                "Profile picture is recommended for better verification. Continue without it?"
              )
            ) {
              this.proceedToVerification();
            }
            return;
          }
          this.proceedToVerification();
        },
        proceedToVerification: function () {
          this.screens.profile.style.display = "none";
          this.screens.verify.style.display = "flex";
          this.state = "ALIGNING";
          this.resetDetection();
          this.startCamera();
          this.updatePromptDisplay();
        },
        // ✅ NEW: Go back to profile page with error handling
        goBackToProfileWithError: function (errorMessage) {
          // Stop all detection and cleanup
          this.stopAllDetection();

          // Show error dialog
          this.showFaceMatchErrorDialog(errorMessage);
        },
        // ✅ NEW: Stop all detection and cleanup
        stopAllDetection: function () {
          // Stop face matching
          this.stopFaceMatching();

          // Stop face detection loop
          if (this.faceDetectionLoop) {
            cancelAnimationFrame(this.faceDetectionLoop);
            this.faceDetectionLoop = null;
          }

          // Stop camera stream
          if (this.stream) {
            this.stream.getTracks().forEach((track) => track.stop());
            this.stream = null;
          }

          // Stop speech recognition
          if (this.speechRecognition) {
            this.speechRecognition.stop();
            this.speechRecognition = null;
          }

          // Stop recording if in progress
          if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
            this.mediaRecorder.stop();
          }

          // Clear intervals
          if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
          }

          // Reset state
          this.state = "PROFILE";
          this.faceDetected = false;
          this.faceMatched = false;
        },
        // ✅ NEW: Show face match error dialog
        showFaceMatchErrorDialog: function (message) {
          // Create error dialog overlay
          const errorDialog = document.createElement("div");
          errorDialog.id = "face-match-error-dialog";
          errorDialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      `;

          errorDialog.innerHTML = `
        <div style="
          background: white;
          border-radius: 12px;
          padding: 24px;
          max-width: 400px;
          width: 90%;
          text-align: center;
        ">
          <div style="
            width: 60px;
            height: 60px;
            background: #fee;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
          ">
            <i data-lucide="alert-triangle" style="color: #dc2626; width: 28px; height: 28px;"></i>
          </div>
          <h3 style="color: #111827; margin: 0 0 12px; font-size: 1.25rem;">
            Face Verification Failed
          </h3>
          <p style="color: #6b7280; margin: 0 0 24px; line-height: 1.5;">
            ${message}
          </p>
          <button id="close-face-match-dialog" style="
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
          ">
            Back to Profile
          </button>
        </div>
      `;

          document.body.appendChild(errorDialog);
          lucide.createIcons();

          // Add close button event listener
          const closeButton = document.getElementById(
            "close-face-match-dialog"
          );
          closeButton.onclick = () => {
            document.body.removeChild(errorDialog);
            // Go back to profile page
            this.screens.verify.style.display = "none";
            this.screens.profile.style.display = "flex";
            this.state = "PROFILE";
          };
        },
        goBackToLanding: function () {
          this.screens.verify.style.display = "none";
          this.screens.profile.style.display = "flex";
          this.state = "PROFILE";
          if (this.stream) {
            this.stream.getTracks().forEach((track) => track.stop());
            this.stream = null;
          }
          this.stopFaceMatching();
        },
        reset: function () {
          this.screens.verify.style.display = "none";
          this.screens.profile.style.display = "none";
          this.screens.userid.style.display = "flex";
          this.state = "USERID";
          this.userId = null;
          this.currentUser = null;
          this.prompts = [];
          this.currentPromptIndex = 0;
          this.profileDescriptor = null;
          this.ui.useridInput.value = "";
          this.ui.useridError.style.display = "none";
          if (this.stream) {
            this.stream.getTracks().forEach((track) => track.stop());
            this.stream = null;
          }
          if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
            this.mediaRecorder.stop();
          }
          this.recordedChunks = [];
          this.videoBlob = null;
          if (this.speechRecognition) this.speechRecognition.stop();
          if (this.timerInterval) clearInterval(this.timerInterval);
          if (this.faceDetectionLoop)
            cancelAnimationFrame(this.faceDetectionLoop);
          this.faceMatched = false;
          this.stopFaceMatching();
        },
        resetDetection: function () {
          this.faceDetected = false;
          this.consecutiveValid = 0;
          this.consecutiveInvalid = 0;
          this.lastReason = "";
        },
        getHandBoundingBox: function (landmarks) {
          if (!landmarks?.length) return null;
          let minX = 1,
            minY = 1,
            maxX = 0,
            maxY = 0;
          for (const lm of landmarks) {
            minX = Math.min(minX, lm.x);
            minY = Math.min(minY, lm.y);
            maxX = Math.max(maxX, lm.x);
            maxY = Math.max(maxY, lm.y);
          }
          return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        },
        startCamera: async function () {
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              video: { width: 640, height: 480, facingMode: "user" },
              audio: true,
            });
            this.ui.video.srcObject = this.stream;
            this.ui.video.onloadedmetadata = () => {
              this.ui.canvas.width = this.ui.video.videoWidth;
              this.ui.canvas.height = this.ui.video.videoHeight;
            };
            this.initFaceDetection();
          } catch (err) {
            this.showError("Camera access denied");
          }
        },
        initFaceDetection: async function () {
          this.ui.faceStatus.textContent = "Loading Model...";
          this.ui.faceStatus.className = "face-status loading";
          try {
            this.faceDetector = new FaceDetection({
              locateFile: (file) =>
                `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`,
            });
            this.faceDetector.setOptions({
              model: "short",
              minDetectionConfidence: 0.6,
            });
            this.faceDetector.onResults((r) => this.onFaceResults(r));
            this.modelLoaded = true;
            this.hands = new Hands({
              locateFile: (file) =>
                `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
            });
            this.hands.setOptions({
              maxNumHands: 2,
              modelComplexity: 0,
              minDetectionConfidence: 0.6,
              minTrackingConfidence: 0.5,
            });
            this.hands.onResults((results) => {
              this.currentHands =
                results.multiHandLandmarks?.length > 0
                  ? results.multiHandedness.map((h, i) => ({
                      label: h.label,
                      bbox: this.getHandBoundingBox(
                        results.multiHandLandmarks[i]
                      ),
                    }))
                  : [];
            });
            this.handsLoaded = true;
            this.updateUI("none", "Detecting face...", "No Face");
            this.runFaceDetection();
          } catch (e) {
            this.showError("Model failed to load");
          }
        },
        runFaceDetection: function () {
          const detect = async () => {
            if (this.state === "USERID" || this.state === "PROFILE") return;
            const video = this.ui.video;
            if (video.readyState >= 2) {
              if (this.modelLoaded)
                await this.faceDetector.send({ image: video });
              if (this.handsLoaded) await this.hands.send({ image: video });
            }
            this.faceDetectionLoop = requestAnimationFrame(detect);
          };
          detect();
        },
        updatePromptDisplay: function () {
          const el = document.getElementById("prompt-text");
          if (el && this.prompts.length > 0) {
            el.textContent = this.prompts[this.currentPromptIndex].text;
          }
        },
        onFaceResults: function (results) {
          if (!results.detections?.length) {
            this.processResult({ valid: false, reason: "No face detected" });
            return;
          }
          if (results.detections.length > 1) {
            this.processResult({
              valid: false,
              reason: "Multiple faces detected",
            });
            return;
          }
          const det = results.detections[0];
          const bbox = det.boundingBox;
          const landmarks = det.landmarks;
          if (!landmarks || landmarks.length < 4) {
            this.processResult({
              valid: false,
              reason: "Face not fully visible",
            });
            return;
          }
          const [rightEye, leftEye, nose, mouth] = landmarks;
          // Check if face is properly visible
          const inBounds = (p) =>
            p && p.x > 0.02 && p.x < 0.98 && p.y > 0.02 && p.y < 0.98;
          if (
            !inBounds(rightEye) ||
            !inBounds(leftEye) ||
            !inBounds(nose) ||
            !inBounds(mouth)
          ) {
            this.processResult({
              valid: false,
              reason: "Face partially covered",
            });
            return;
          }
          // Check hand overlap
          if (this.currentHands.length > 0) {
            const fL = bbox.xCenter - bbox.width / 2;
            const fR = bbox.xCenter + bbox.width / 2;
            const fT = bbox.yCenter - bbox.height / 2;
            const fB = bbox.yCenter + bbox.height / 2;
            for (const hand of this.currentHands) {
              if (!hand.bbox) continue;
              const hL = hand.bbox.x;
              const hR = hand.bbox.x + hand.bbox.width;
              const hT = hand.bbox.y;
              const hB = hand.bbox.y + hand.bbox.height;
              const oX = Math.max(0, Math.min(fR, hR) - Math.max(fL, hL));
              const oY = Math.max(0, Math.min(fB, hB) - Math.max(fT, hT));
              if (oX > 0 && oY > 0) {
                this.processResult({
                  valid: false,
                  reason: "Remove hand from face",
                });
                return;
              }
            }
          }
          // Check if face is in circle
          const c = this.circle;
          const allIn = [rightEye, leftEye, nose, mouth].every((p) =>
            this.isInsideCircle(p.x, p.y, c)
          );
          if (!allIn) {
            this.processResult({
              valid: false,
              reason: "Position face inside circle",
            });
            return;
          }
          // Check face size
          const sizeRatio = Math.max(bbox.width, bbox.height) / (c.r * 2);
          if (sizeRatio < 0.25) {
            this.processResult({ valid: false, reason: "Move closer" });
            return;
          }
          if (sizeRatio > 1.2) {
            this.processResult({ valid: false, reason: "Move farther" });
            return;
          }
          this.processResult({ valid: true, reason: "" });
        },
        isInsideCircle: function (x, y, c) {
          const dx = x - c.cx,
            dy = y - c.cy;
          return Math.sqrt(dx * dx + dy * dy) <= c.r;
        },
        processResult: function (result) {
          if (result.valid) {
            this.consecutiveValid++;
            this.consecutiveInvalid = 0;
            this.lastReason = "";
          } else {
            this.consecutiveInvalid++;
            this.consecutiveValid = 0;
            this.lastReason = result.reason;
          }
          if (
            this.state === "RECORDING" &&
            !result.valid &&
            this.consecutiveInvalid >= 2
          ) {
            this.stopRecordingDueToError("Face lost during recording");
            return;
          }
          if (!this.faceDetected && this.consecutiveValid >= this.threshold) {
            this.onFaceValid();
          } else if (
            this.faceDetected &&
            this.consecutiveInvalid >= this.threshold
          ) {
            this.onFaceInvalid(this.lastReason);
          } else if (!this.faceDetected && this.consecutiveInvalid >= 2) {
            this.showErrorMessage(this.lastReason);
          }
        },
        showErrorMessage: function (reason) {
          this.ui.videoBorder.className = "video-circle no-face";
          this.ui.faceStatus.textContent = "Adjust Face";
          this.ui.faceStatus.className = "face-status not-detected";
          this.ui.errorMessage.textContent = reason;
          this.ui.errorToast.style.display = "flex";
          this.ui.instruction.textContent = reason;
          this.ui.instruction.className = "instruction-text error";
        },
        onFaceValid: function () {
          this.faceDetected = true;
          this.ui.videoBorder.className = "video-circle face-detected";
          this.ui.faceStatus.textContent = "Face Detected ✓";
          this.ui.faceStatus.className = "face-status detected";
          this.ui.errorToast.style.display = "none";
          this.ui.instruction.textContent = "Face Detected";
          this.ui.instruction.className = "instruction-text";
          if (this.state === "ALIGNING") {
            this.state = "READY";
            if (this.currentUser?.profilePic && this.profileDescriptor) {
              this.startFaceMatching();
            } else {
              this.faceMatched = true;
              this.ui.btn.disabled = false;
              this.ui.btn.textContent = "Start Recording";
            }
          }
        },
        onFaceInvalid: function (reason) {
          this.faceDetected = false;
          this.showErrorMessage(reason);
          if (this.state === "READY") {
            this.state = "ALIGNING";
            this.ui.btn.disabled = true;
            this.ui.btn.textContent = "Detecting Face...";
            this.stopFaceMatching();
          }
        },
        showError: function (msg) {
          this.ui.errorMessage.textContent = msg;
          this.ui.errorToast.style.display = "flex";
          this.ui.instruction.textContent = msg;
          this.ui.instruction.className = "instruction-text error";
        },
        updateUI: function (borderClass, btnText, statusText) {
          if (borderClass !== "none")
            this.ui.videoBorder.className = "video-circle " + borderClass;
          this.ui.btn.textContent = btnText;
          this.ui.faceStatus.textContent = statusText;
        },
        handleAction: function () {
          if (this.state === "READY") {
            if (!this.faceMatched) {
              this.showError("Face verification required");
              return;
            }
            this.startRecording();
          } else if (this.state === "RECORDING") {
            this.stopRecording();
          } else if (this.state === "ERROR") {
            this.retryVerification();
          }
        },
        startSpeechRecognition: function () {
          this.recognizedText = "";
          const SpeechRecognition =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SpeechRecognition) return;
          try {
            this.speechRecognition = new SpeechRecognition();
            this.speechRecognition.continuous = false;
            this.speechRecognition.interimResults = false;
            this.speechRecognition.lang = "en-US";
            this.speechRecognition.onresult = (event) => {
              if (event.results.length > 0) {
                this.recognizedText = event.results[0][0].transcript
                  .trim()
                  .toLowerCase();
                console.log("Recognized:", this.recognizedText);
              }
            };
            this.speechRecognition.onerror = (event) => {
              console.warn("Speech recognition error:", event.error);
            };
            this.speechRecognition.start();
          } catch (error) {
            console.warn("Could not start speech recognition:", error);
          }
        },
        startFaceMatching: async function () {
          if (!this.faceApiModelsLoaded) {
            console.warn("Face-API models not loaded");
            this.faceMatched = true;
            this.ui.btn.disabled = false;
            this.ui.btn.textContent = "Start Recording";
            return;
          }
          if (!this.profileDescriptor) {
            console.warn("No profile descriptor available");
            this.faceMatched = true;
            this.ui.btn.disabled = false;
            this.ui.btn.textContent = "Start Recording";
            return;
          }
          this.showFaceMatchStatus("Verifying face match...", true);
          this.faceMatched = false;
          // Start continuous face matching
          this.faceMatchingInterval = setInterval(async () => {
            try {
              const video = this.ui.video;
              if (video.readyState < 2) return;
              // Detect face in current video frame
              const detection = await faceapi
                .detectSingleFace(video)
                .withFaceLandmarks()
                .withFaceDescriptor();
              if (!detection) {
                // Don't update if already matched (face temporarily lost)
                if (!this.faceMatched) {
                  this.showFaceMatchStatus("No face detected in frame", false);
                }
                return;
              }
              // Calculate Euclidean distance between descriptors
              const distance = faceapi.euclideanDistance(
                this.profileDescriptor,
                detection.descriptor
              );
              console.log("Face match distance:", distance.toFixed(3));
              // Distance threshold: < 0.6 is a match
              const threshold = 0.6;
              const similarity = Math.max(0, 1 - distance / threshold);
              const similarityPercent = similarity * 100;

              // ✅ NEW: Check if similarity is below 33%
              if (similarityPercent < 33) {
                // Stop all detection and show error
                this.stopFaceMatchingInterval();
                this.goBackToProfileWithError(
                  "Your face does not match the profile picture. Please ensure you are the same person as in the profile picture."
                );
                return;
              }

              if (distance < threshold && similarityPercent >= 70) {
                // ✅ Face matched at 70% or higher - STOP MATCHING
                this.faceMatched = true;
                this.showFaceMatchStatus(
                  `Face Matched ✓ (${similarityPercent.toFixed(1)}%)`,
                  true
                );
                if (this.state === "READY") {
                  this.ui.btn.disabled = false;
                  this.ui.btn.textContent = "Start Recording";
                }
                // STOP the interval - no more matching needed
                console.log(
                  "✅ Face match verified at",
                  similarityPercent.toFixed(1) + "% - Stopping verification"
                );
                this.stopFaceMatchingInterval();
              } else {
                // Face not matched or below 70%
                if (!this.faceMatched) {
                  this.showFaceMatchStatus(
                    `Face Not Matched (${similarityPercent.toFixed(1)}%)`,
                    false
                  );
                  if (this.state === "READY") {
                    this.ui.btn.disabled = true;
                  }
                }
              }
            } catch (error) {
              console.error("Face matching error:", error);
            }
          }, 1500); // Check every 1.5 seconds
        },
        stopFaceMatchingInterval: function () {
          // Stop the interval but keep faceMatched = true
          if (this.faceMatchingInterval) {
            clearInterval(this.faceMatchingInterval);
            this.faceMatchingInterval = null;
            console.log("Face matching interval stopped");
          }
        },
        stopFaceMatching: function () {
          // This is called when going back or on error - full reset
          if (this.faceMatchingInterval) {
            clearInterval(this.faceMatchingInterval);
            this.faceMatchingInterval = null;
          }
          this.faceMatched = false;
          this.hideFaceMatchStatus();
        },
        showFaceMatchStatus: function (message, isSuccess = true) {
          if (!this.ui.faceMatchStatus) return;
          this.ui.faceMatchMessage.textContent = message;
          this.ui.faceMatchStatus.style.display = "flex";
          this.ui.faceMatchStatus.className = `face-match-status ${
            isSuccess ? "" : "error"
          }`;
        },
        hideFaceMatchStatus: function () {
          if (!this.ui.faceMatchStatus) return;
          this.ui.faceMatchStatus.style.display = "none";
        },
        startRecording: function () {
          if (!this.faceDetected || !this.faceMatched) return;
          this.startSpeechRecognition();
          this.recordedChunks = [];
          const options = { mimeType: "video/webm;codecs=vp9" };
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = "video/webm";
          }
          this.mediaRecorder = new MediaRecorder(this.stream, options);
          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) this.recordedChunks.push(event.data);
          };
          this.mediaRecorder.onstop = () => {
            this.videoBlob = new Blob(this.recordedChunks, {
              type: options.mimeType,
            });
          };
          this.mediaRecorder.start();
          this.state = "RECORDING";
          this.ui.btn.textContent = "Stop Recording";
          this.ui.btn.className = "btn btn-red";
          this.ui.recIndicator.style.display = "flex";
          this.ui.errorToast.style.display = "none";
          this.ui.instruction.textContent = "Recording... Read the text aloud";
          this.ui.instruction.className = "instruction-text";
          let t = this.getRecordingDuration();
          this.updateTimerDisplay(t);
          this.timerInterval = setInterval(() => {
            t--;
            this.updateTimerDisplay(t);
            if (t <= 0) this.stopRecording();
          }, 1000);
        },
        updateTimerDisplay: function (seconds) {
          const sec = String(seconds).padStart(2, "0");
          this.ui.timerText.textContent = `00:${sec}`;
        },
        stopRecording: function () {
          if (this.timerInterval) clearInterval(this.timerInterval);
          if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
            this.mediaRecorder.stop();
          }
          if (this.speechRecognition) this.speechRecognition.stop();
          this.state = "UPLOADING";
          this.ui.loading.style.display = "flex";
          this.ui.btn.textContent = "Verifying...";
          this.ui.btn.disabled = true;
          this.ui.recIndicator.style.display = "none";
          setTimeout(() => this.verifyTranscript(), 1000);
        },
        verifyTranscript: function () {
          if (
            !this.prompts.length ||
            this.currentPromptIndex >= this.prompts.length
          ) {
            this.triggerError();
            return;
          }
          const currentPrompt = this.prompts[this.currentPromptIndex];
          const expected = currentPrompt.text.toLowerCase();
          const expectedClean = expected.replace(/[^a-z0-9]/g, "");
          const recognizedClean = this.recognizedText.replace(/[^a-z0-9]/g, "");
          console.log(
            "Expected:",
            expectedClean,
            "| Recognized:",
            recognizedClean
          );
          let isMatch = false;
          if (currentPrompt.type === "otp") {
            const expectedDigits = expected.replace(/\D/g, "");
            const recognizedDigits = recognizedClean.replace(/\D/g, "");
            isMatch = expectedDigits === recognizedDigits;
          } else {
            const expectedWords = expectedClean
              .split(" ")
              .filter((w) => w.length > 2);
            const matchedWords = expectedWords.filter((word) =>
              recognizedClean.includes(word)
            );
            isMatch =
              matchedWords.length >= Math.ceil(expectedWords.length * 0.6);
          }
          if (isMatch) {
            this.uploadVideoAndComplete();
          } else {
            this.triggerError();
          }
        },
        uploadVideoAndComplete: async function () {
          try {
            // Capture profile picture
            const canvas = this.ui.canvas;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(this.ui.video, 0, 0, canvas.width, canvas.height);
            const profileBlob = await new Promise((resolve) => {
              canvas.toBlob(resolve, "image/jpeg", 0.8);
            });
            if (!profileBlob)
              throw new Error("Failed to capture profile picture");
            // Upload profile picture
            const profileFormData = new FormData();
            profileFormData.append("profilePic", profileBlob, "profile.jpg");
            const profileResponse = await fetch(
              `${this.API_BASE}/users/${this.userId}/profile/upload`,
              { method: "POST", body: profileFormData }
            );
            if (!profileResponse.ok) {
              const error = await profileResponse.json();
              throw new Error(
                "Profile upload failed: " + (error.error || "Unknown error")
              );
            }
            // Upload video
            if (!this.videoBlob) throw new Error("No video recorded");
            const videoFormData = new FormData();
            videoFormData.append("video", this.videoBlob, "kyc_video.webm");
            videoFormData.append(
              "prompt",
              this.prompts[this.currentPromptIndex].text
            );
            const videoResponse = await fetch(
              `${this.API_BASE}/users/${this.userId}/video-kyc/upload`,
              { method: "POST", body: videoFormData }
            );
            if (!videoResponse.ok) {
              const error = await videoResponse.json();
              throw new Error(
                "Video upload failed: " + (error.error || "Unknown error")
              );
            }
            const videoData = await videoResponse.json();
            // Update metadata
            const metadataResponse = await fetch(
              `${this.API_BASE}/users/${this.userId}/video-kyc`,
              {
                method: "PATCH",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  videoKycTranscript: this.recognizedText,
                  videoKycRecVideo: videoData.data.filename,
                  verificationMethod:
                    this.prompts[this.currentPromptIndex].type,
                  videoKycMeta: {
                    duration: this.getRecordingDuration(),
                    prompt: this.prompts[this.currentPromptIndex].text,
                    faceDetected: true,
                    handDetected: this.currentHands.length > 0,
                    recordingDate: new Date().toISOString(),
                  },
                }),
              }
            );
            if (!metadataResponse.ok) {
              const error = await metadataResponse.json();
              throw new Error(
                "Metadata update failed: " + (error.error || "Unknown error")
              );
            }
            // Verify KYC
            const verifyResponse = await fetch(
              `${this.API_BASE}/users/${this.userId}/video-kyc/verify`,
              { method: "POST" }
            );
            if (!verifyResponse.ok) {
              const error = await verifyResponse.json();
              throw new Error(
                "KYC verification failed: " + (error.error || "Unknown error")
              );
            }
            this.ui.loading.style.display = "none";
            this.ui.instruction.textContent = "✅ KYC Verification Successful!";
            this.ui.instruction.className = "instruction-text";
            setTimeout(() => this.reset(), 2000);
          } catch (error) {
            console.error("Upload error:", error);
            this.showError("Verification failed: " + error.message);
            this.triggerError();
          } finally {
            this.hideFaceMatchStatus();
          }
        },
        stopRecordingDueToError: function (message) {
          if (this.timerInterval) clearInterval(this.timerInterval);
          if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
            this.mediaRecorder.stop();
          }
          if (this.speechRecognition) {
            this.speechRecognition.stop();
            this.speechRecognition = null;
          }
          this.state = "ERROR";
          this.faceDetected = false;
          this.ui.recIndicator.style.display = "none";
          this.ui.loading.style.display = "none";
          this.showErrorMessage(message);
          this.ui.btn.textContent = "Re-record Video";
          this.ui.btn.disabled = false;
          this.ui.btn.className = "btn btn-primary";
          this.stopFaceMatching();
        },
        triggerError: function () {
          this.state = "ERROR";
          this.ui.loading.style.display = "none";
          this.ui.videoBorder.className = "video-circle no-face";
          this.ui.errorMessage.textContent =
            "Verification failed. Please try again.";
          this.ui.errorToast.style.display = "flex";
          this.ui.instruction.textContent = "Verification failed";
          this.ui.instruction.className = "instruction-text error";
          this.ui.btn.textContent = "Re-record Video";
          this.ui.btn.disabled = false;
          this.ui.btn.className = "btn btn-primary";
          this.stopFaceMatching();
        },
        getRecordingDuration: function () {
          if (
            !this.prompts.length ||
            this.currentPromptIndex >= this.prompts.length
          ) {
            return 4;
          }
          const prompt = this.prompts[this.currentPromptIndex];
          return prompt.duration || (prompt.type === "otp" ? 4 : 8);
        },
        retryVerification: function () {
          this.currentPromptIndex =
            (this.currentPromptIndex + 1) % this.prompts.length;
          this.updatePromptDisplay();
          this.resetDetection();
          this.state = "ALIGNING";
          this.faceDetected = false;
          this.ui.errorToast.style.display = "none";
          this.ui.videoBorder.className = "video-circle no-face";
          this.ui.faceStatus.textContent = "No Face";
          this.ui.faceStatus.className = "face-status not-detected";
          this.ui.btn.textContent = "Detecting Face...";
          this.ui.btn.disabled = true;
          this.ui.instruction.textContent =
            "Position your face inside the circle";
          this.ui.instruction.className = "instruction-text";
          if (!this.faceDetectionLoop) {
            this.runFaceDetection();
          }
          if (this.currentUser?.profilePic && this.profileDescriptor) {
            setTimeout(() => {
              if (this.state === "READY") {
                this.startFaceMatching();
              }
            }, 1000);
          }
        },
      };
      // Initialize Face-API models on page load
      window.addEventListener("DOMContentLoaded", () => {
        app.init();
      });
      window.app = app;
    </script>
  </body>
</html>
